using FSH.WebApi.Application.Accounting.Dtos;
using FSH.WebApi.Application.Common.Interfaces;
using FSH.WebApi.Domain.Accounting;
using FSH.WebApi.Domain.Accounting.Enums;
using FSH.WebApi.Application.Common.Exceptions;
using FSH.WebApi.Application.Common.Persistence; // For IRepository
using Mapster; // For mapping

namespace FSH.WebApi.Application.Accounting;

public class JournalEntryService : IJournalEntryService
{
    private readonly IRepository<JournalEntry> _journalEntryRepository;
    private readonly IRepository<Account> _accountRepository; // Needed for transaction validation and updates
    // private readonly IStringLocalizer<JournalEntryService> _localizer;

    public JournalEntryService(IRepository<JournalEntry> journalEntryRepository, IRepository<Account> accountRepository /*, IStringLocalizer<JournalEntryService> localizer*/)
    {
        _journalEntryRepository = journalEntryRepository;
        _accountRepository = accountRepository;
        // _localizer = localizer;
    }

    public async Task<Guid> CreateJournalEntryAsync(CreateJournalEntryRequest request, CancellationToken cancellationToken)
    {
        // Basic validation
        if (request.Transactions == null || !request.Transactions.Any())
        {
            throw new ArgumentException("Journal entry must have at least one transaction.");
        }

        var journalEntry = new JournalEntry(request.EntryDate, request.Description);

        foreach (var transReq in request.Transactions)
        {
            var account = await _accountRepository.GetByIdAsync(transReq.AccountId, cancellationToken)
                ?? throw new NotFoundException($"Account with ID {transReq.AccountId} not found for a transaction.");

            // The Transaction entity constructor takes journalEntryId, which isn't set until JournalEntry is created.
            // We'll create transaction objects and add them.
            // The actual Transaction entity would typically be created here and added to the JournalEntry.
            // For now, we are simulating this. In a real setup, the Transaction object would be fully formed.
        }
        // This is a simplified representation. In a real system, you'd create Transaction entities
        // and add them to journalEntry.Transactions. The domain logic for this is in JournalEntry.AddTransaction.
        // journalEntry.AddTransaction would need a fully-fledged Transaction object.

        // Placeholder for creating actual Transaction entities from TransactionRequest
        // This requires a bit more setup with the Transaction constructor and JournalEntry relationships.
        // For now, we assume the JournalEntry's constructor or a method handles this creation internally
        // if we were to pass simplified transaction data.
        // However, the current JournalEntry.AddTransaction expects a Transaction object.

        // Let's refine this:
        List<Transaction> transactions = new List<Transaction>();
        foreach (var transReq in request.Transactions)
        {
            // We need to ensure the account exists before creating a transaction for it.
            var account = await _accountRepository.GetByIdAsync(transReq.AccountId, cancellationToken);
            _ = account ?? throw new NotFoundException($"Account with ID {transReq.AccountId} not found.");

            // Note: The Transaction domain entity has a constructor that takes journalEntryId.
            // This creates a slight challenge here as journalEntry.Id is not yet generated by the DB.
            // This implies that either Transaction entities are created without JournalEntryId initially
            // and set later, or the JournalEntry itself is responsible for creating Transaction instances.
            // For now, let's assume we create transactions and the ORM handles the relationship.
            // The JournalEntry.AddTransaction method is the correct way to add transactions.
        }

        // The JournalEntry.Post() method which includes ValidateTransactions() cannot be called
        // until accounts are associated with transactions.
        // The actual transaction creation logic will be more complex.
        // This is a placeholder. The actual implementation would involve creating Transaction entities,
        // associating them with accounts, and then adding them to the journal entry.

        // Simplified:
        var newJournalEntry = new JournalEntry(request.EntryDate, request.Description);
        // Transactions would be added here using newJournalEntry.AddTransaction(...)
        // after being properly constructed with account and journal entry references.
        // This part will be more fleshed out with actual DB context and entity tracking.

        await _journalEntryRepository.AddAsync(newJournalEntry, cancellationToken);
        // Simulate adding transactions after JE is created to get its ID for FK,
        // or rely on ORM to handle nested creations.
        // For now, we are returning the ID of the JE. Transactions would be part of its aggregate.

        return newJournalEntry.Id;
    }

    public async Task<JournalEntryDto> GetJournalEntryByIdAsync(Guid id, CancellationToken cancellationToken)
    {
        var journalEntry = await _journalEntryRepository.GetByIdAsync(id, cancellationToken); // Assuming Include for Transactions
        _ = journalEntry ?? throw new NotFoundException($"JournalEntry with ID {id} not found.");

        // Manual mapping or Mapster
        return new JournalEntryDto
        {
            Id = journalEntry.Id,
            EntryDate = journalEntry.EntryDate,
            Description = journalEntry.Description,
            Status = journalEntry.Status,
            CreatedOn = journalEntry.CreatedOn,
            LastModifiedOn = journalEntry.LastModifiedOn,
            Transactions = journalEntry.Transactions.Select(t => new TransactionDto // Assuming Transactions are loaded
            {
                Id = t.Id,
                AccountId = t.AccountId,
                AccountName = t.Account?.AccountName ?? "N/A", // Requires Account to be loaded
                TransactionType = t.TransactionType,
                Amount = t.Amount,
                Description = t.Description,
                TransactionDate = t.TransactionDate,
                CreatedOn = t.CreatedOn,
                LastModifiedOn = t.LastModifiedOn
            }).ToList()
        };
    }

    public async Task<JournalEntryDto> UpdateJournalEntryAsync(Guid id, UpdateJournalEntryRequest request, CancellationToken cancellationToken)
    {
        var journalEntry = await _journalEntryRepository.GetByIdAsync(id, cancellationToken);
        _ = journalEntry ?? throw new NotFoundException($"JournalEntry with ID {id} not found.");

        if (journalEntry.Status != JournalEntryStatus.Draft)
        {
            throw new InvalidOperationException("Only draft journal entries can be updated.");
        }

        journalEntry.UpdateJournalEntryDetails(request.EntryDate, request.Description);

        // Handling transactions update:
        // This could be complex: removing old, adding new, updating existing.
        // For simplicity, let's assume a replace model if the domain entity supports it,
        // or clear and add. The current JournalEntry domain model has Add/Remove.
        // This is a placeholder for more robust transaction management.
        journalEntry.Transactions.Clear(); // Simplistic approach

        foreach (var transReq in request.Transactions)
        {
            var account = await _accountRepository.GetByIdAsync(transReq.AccountId, cancellationToken)
                ?? throw new NotFoundException($"Account with ID {transReq.AccountId} not found for a transaction.");
            // Again, Transaction construction and addition to JournalEntry needs care.
            // For now, this is conceptual.
            // journalEntry.AddTransaction(new Transaction(...));
        }

        await _journalEntryRepository.UpdateAsync(journalEntry, cancellationToken);
        return await GetJournalEntryByIdAsync(id, cancellationToken); // Re-fetch to get updated state including transactions
    }

    public async Task<bool> PostJournalEntryAsync(Guid id, CancellationToken cancellationToken)
    {
        var journalEntry = await _journalEntryRepository.GetByIdAsync(id, cancellationToken); // Ensure Transactions and their Accounts are loaded
        _ = journalEntry ?? throw new NotFoundException($"JournalEntry with ID {id} not found.");

        // The JournalEntry.Post() method requires that its Transactions collection is populated
        // AND that each Transaction's Account navigation property is also populated.
        // This needs to be handled by the repository's GetByIdAsync (e.g. using .Include(...).ThenInclude(...))
        // For this placeholder, we assume they are loaded. If not, Post() will fail.
        // A proper implementation would ensure all necessary data is loaded.

        // Example of what might be needed if not handled by a generic repository:
        // var journalEntryWithDetails = await _dbContext.JournalEntries
        // .Include(je => je.Transactions)
        // .ThenInclude(t => t.Account)
        // .FirstOrDefaultAsync(je => je.Id == id, cancellationToken);
        // _ = journalEntryWithDetails ?? throw new NotFoundException($"JournalEntry with ID {id} not found.");

        journalEntry.Post(); // Domain logic handles status change and account balance updates
        await _journalEntryRepository.UpdateAsync(journalEntry, cancellationToken); // Persist changes
        // Note: Account balance changes also need to be persisted. This might require SaveChangesAsync on the DbContext
        // or specific updates for each affected account if not handled by the ORM's change tracking via JournalEntry.
        // This typically means IUnitOfWork.SaveChangesAsync() if transactions are part of the same unit of work.

        return true;
    }

    public async Task<bool> VoidJournalEntryAsync(Guid id, CancellationToken cancellationToken)
    {
        var journalEntry = await _journalEntryRepository.GetByIdAsync(id, cancellationToken); // Similar loading requirements as Post
        _ = journalEntry ?? throw new NotFoundException($"JournalEntry with ID {id} not found.");

        journalEntry.Void(); // Domain logic handles status change and reverting account balances
        await _journalEntryRepository.UpdateAsync(journalEntry, cancellationToken); // Persist changes
        // Similar persistence considerations for Account entities apply here as in Post.

        return true;
    }

    public async Task<List<JournalEntryDto>> SearchJournalEntriesAsync(SearchJournalEntriesRequest request, CancellationToken cancellationToken)
    {
        // Placeholder: Real implementation needs IReadRepository and Specification, or dynamic query building.
        var allEntries = await _journalEntryRepository.ListAsync(cancellationToken); // Not efficient

        var filteredEntries = allEntries
            .Where(je => (!request.StartDate.HasValue || je.EntryDate >= request.StartDate.Value) &&
                         (!request.EndDate.HasValue || je.EntryDate <= request.EndDate.Value) &&
                         (!request.Status.HasValue || je.Status == request.Status.Value) &&
                         (string.IsNullOrWhiteSpace(request.DescriptionKeyword) || je.Description.Contains(request.DescriptionKeyword, StringComparison.OrdinalIgnoreCase)) &&
                         (!request.AccountId.HasValue || je.Transactions.Any(t => t.AccountId == request.AccountId.Value)))
            .ToList();

        // Manual mapping or Mapster
        return filteredEntries.Select(je => new JournalEntryDto
        {
            Id = je.Id,
            EntryDate = je.EntryDate,
            Description = je.Description,
            Status = je.Status,
            CreatedOn = je.CreatedOn,
            LastModifiedOn = je.LastModifiedOn,
            Transactions = je.Transactions.Select(t => new TransactionDto
            {
                Id = t.Id,
                AccountId = t.AccountId,
                AccountName = t.Account?.AccountName ?? "N/A",
                TransactionType = t.TransactionType,
                Amount = t.Amount,
                Description = t.Description,
                TransactionDate = t.TransactionDate,
                CreatedOn = t.CreatedOn,
                LastModifiedOn = t.LastModifiedOn
            }).ToList()
        })
        .Skip((request.PageNumber - 1) * request.PageSize)
        .Take(request.PageSize)
        .ToList();
    }
}
